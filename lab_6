(define (++ x) (+ x 1))
(define (-- x) (- x 1))
(define-syntax trace-ex
  (syntax-rules ()
    ((trace-ex expr)
     (begin (write 'expr)
            (display " => ")
            (let ((x expr))
              (write x)
              (newline)
              x)))))
;;1
(define (check-frac str);> (check-frac "/1") #t not
  (define check-frac-arr (string->list "1234567890-/+"))
  (define chek-number (string->list "1234567890"))
  (define (loop arr flag-+ flag/ flag-num)
    
    (cond((null? arr) #t)
         ((memq (car arr) chek-number)(loop (cdr arr) flag-+ flag/ (++ flag-num)))
         ((and (= (length arr) 1) (memq (car arr) check-frac-arr) (not (memq (car arr) chek-number))) #f)
         ((and (= flag-num 0) (equal? (car arr) #\/)) #f);;loop -> false
         ((and (memq (car arr) check-frac-arr) (not (or (equal? (car arr) #\-) (equal? (car arr)#\/)))) (loop (cdr arr) flag-+ flag/ flag-num))
         ((and (memq (car arr) check-frac-arr) (or (equal? (car arr) #\-) (equal? (car arr) #\+)) (= flag-+ 0 flag/)) (loop (cdr arr) (++ flag-+) flag/ flag-num))
         ((and (memq (car arr) check-frac-arr) (equal? (car arr) #\/) (= flag/ 0)) (loop (cdr arr) flag-+ (++ flag/) flag-num))
         (else #f)))
  (loop (string->list str) 0 0 0))

(define (char->digit ch)
  (- (char->integer ch) (char->integer #\0)))

(define (scan-frac str)
  (define (loop arr up down flag/ sgn)
    #|
    (write "     ")
    (display up)
    (write "/")
    (display down)
    (newline)
    |#
    (cond ((null? arr) (/ up down sgn))
          ((equal? (car arr) #\/) (loop (cdr arr) up down 1 sgn))
          ((equal? (car arr) #\+) (loop (cdr arr) up down flag/ +1))
          ((equal? (car arr) #\-) (loop (cdr arr) up down flag/ -1))
          ((= flag/ 0) (loop (cdr arr) (+ (* up 10)  (char->digit (car arr))) down flag/ sgn))
          (else (loop (cdr arr) up (+ (* down 10) (char->digit (car arr))) flag/ sgn))))
  (and (check-frac str) (loop (string->list str) 0 0 0 1)))

(define (search-f res arr)
  (if (null? arr)
      res
      (if (car arr)
          (search-f res (cdr arr))
          #f)))
      

(define (scan-many-fracs str)
  (define skip '(#\space #\tab #\newline))
  (define (loop arr frac res)
    (cond ((and (not (null? frac)) (null? arr)) (append res (list (scan-frac (list->string frac)))))
          ((null? arr)res)
          ;((equal? (car arr) #\\) (scan-frac (list->string frac)) (loop (cddr arr '())))
          ;((equal? (car arr) #\space) (scan-frac (list->string frac)) (loop (cdr arr)'()))
          ((and (not (null? frac)) (memq (car arr) skip));(write "|")(display (scan-frac (list->string frac)))
           (loop (cdr arr)'() (append res (list (scan-frac (list->string frac))))))
          ((memq (car arr) skip) (loop (cdr arr) frac res))
          (else ;(display (car arr))(newline)
           (loop (cdr arr) (append frac (list (car arr))) res))))
  (let ((arr (loop (string->list str) '() '())))
    (search-f arr arr)))


;;2
(define __eval__ (lambda (x) (eval x (interaction-environment))))
;(define funcs-arr '('+ '- '* 'mod 'neg '= '< '> 'not 'and 'or 'drop 'swap 'dup 'over 'rot 'depth 'if))
(define funcs-arr '(+ - * mod neg = < > not and or drop swap dup over rot depth))

(define dict '())


(define (parse vec)
  ;(parce (vector->list vec) (list dict '())))
  (let ((parsed (parce (vector->list vec) '())))
    (if (and (cdr parsed) (not (equal? (cdr parsed) '((if #f)))))
        (list dict parsed)
        #f)))
    
  ;(begin (parce (vector->list vec) '())
   ;      (list dict (parce (vector->list vec) '()))));подумать как  сделать один вызов функции
;;define end -> #f
;;if define endif end -> #f
;; if define end  endif -> #f
(define (parce-define arr stack-return)
  #|
  (display "  | arr ")
  (write arr)
  (newline)
  (display "dict ")
  (display dict)
  (newline)
  (display "stack-reurn ")
  (write stack-return)
  (newline)
  |#
  (if (equal? (car arr) 'end)
      (begin (set! dict (cons  (cons (car stack-return) (list (cdr stack-return)))    dict))
             (cdr arr))
      (parce-define (cdr arr) (append  stack-return (list (car arr))))))
#|
(define (parce-if arr res)
  (if (equal? (car arr) 'endif)
      res
      (parce-if (cdr arr) (cons (car arr) res))))
|#
(define (parce-if arr res)
  (cond ((null? arr) #f);; arr -> #f
        ((equal? (car arr) 'define) #f)
        ((equal? (car arr) 'if)
         (let ((add-if (parce-if (cdr arr) '())))
           (parce-if (parce-endif (cdr arr)) (append res (list (list 'if add-if))))))
        ((equal? (car arr) 'endif) res)
        (else (parce-if (cdr arr) (append res (list (car arr)))))))
#|
(define (parce-endif arr)
  (if (equal? (car arr) 'endif)
      (cdr arr)
      (parce-endif (cdr arr))))
|#
(define (parce-endif arr)
  (cond ((null? arr) '())
        ((equal? (car arr) 'if) (parce-endif (parce-endif (cdr arr))))
        ((equal? (car arr) 'endif);(display arr)(newline)
         (cdr arr))
        (else (parce-endif (cdr arr)))))

(define (parce arr res)
  ;(write res)
  ;(newline)
  (if (null? arr)
      res
      (let ((fnel (car arr)))
        (cond ((member fnel funcs-arr) (parce (cdr arr) (append res (list fnel))))
              ((equal? fnel 'define);(display " define ")
               (if (> (length arr) 3)
                (parce (parce-define (cdr arr) '()) res)
                #f))
              ;((equal? fnel 'if) (display " if ") (parce (parce-endif arr 0) (append res (list parce-if (cdr arr) 0 '()))))
              ((equal? fnel 'if) ;(display " if ")
               (let ((add-if (parce-if (cdr arr) '())))
                 (parce (parce-endif arr) (append res (list (list 'if add-if))))))
              ((number? fnel) (parce (cdr arr) (append res (list fnel))))
              ((equal? fnel 'end) #f)
              ((equal? fnel 'endif) #f)
              ((or (equal? fnel 'x) (assoc fnel dict)) (parce (cdr arr) (append res (list fnel))));;x можнo?
              (else (write fnel) (newline) #f)))))

#|

(define (scan-frac str)
  (define check-frac-arr (string->list "1234567890-/+"))
  (define frac 0)
  (define quot 0)
  (define sgn +)
  (define (loop listr aft)
    (cond
      ((null? listr) #t)
      ((memq (car listr) check-frac-arr)
       (cond
         ((equal? (car listr)#\/) (loop (cdr listr) 1))
         ((equal? (car listr)#\+) (loop (cdr listr) aft))
         ((and  (equal? (car listr) #\-) (= aft 0)) (set! sgn -) (loop (cdr listr) aft))
         ((and  (equal? (car listr) #\-) (= aft 1)) #f)
         (else
          (or
           (and (equal? aft 0) (set! frac (sgn (* frac 10)
                                               (char->digit (car listr)))))
           (and (equal? aft 1) (set! quot (+ (* quot 10)
                                             (char->digit (car listr))))))
          (loop (cdr listr) aft))))
      (else #f)))
  (and (loop (string->list str) 0)
       (not (= quot 0)) ;; не знаю, надо ли проверять деление на 0
       (/ frac quot))) ;; выводить через write! display выводит целую часть из дробей, нам этого не надо!
|#
