(define (++ x) (+ x 1))
(define-syntax trace-ex
  (syntax-rules ()
    ((trace-ex expr)
     (begin (write 'expr)
            (display " => ")
            (let ((x expr))
              (write x)
              (newline)
              x)))))
;;1
(define (check-frac str);> (check-frac "/1") #t not
  (define check-frac-arr (string->list "1234567890-/+"))
  (define chek-number (string->list "1234567890"))
  (define (loop arr flag-+ flag/ flag-num)
    
    (cond((null? arr) #t)
         ((memq (car arr) chek-number)(loop (cdr arr) flag-+ flag/ (++ flag-num)))
         ((and (= (length arr) 1) (memq (car arr) check-frac-arr) (not (memq (car arr) chek-number))) #f)
         ((and (= flag-num 0) (equal? (car arr) #\/)) #f);;loop -> false
         ((and (memq (car arr) check-frac-arr) (not (or (equal? (car arr) #\-) (equal? (car arr)#\/)))) (loop (cdr arr) flag-+ flag/ flag-num))
         ((and (memq (car arr) check-frac-arr) (or (equal? (car arr) #\-) (equal? (car arr) #\+)) (= flag-+ 0 flag/)) (loop (cdr arr) (++ flag-+) flag/ flag-num))
         ((and (memq (car arr) check-frac-arr) (equal? (car arr) #\/) (= flag/ 0)) (loop (cdr arr) flag-+ (++ flag/) flag-num))
         (else #f)))
  (loop (string->list str) 0 0 0))

(define (char->digit ch)
  (- (char->integer ch) (char->integer #\0)))

(define (scan-frac str)
  (define (loop arr up down flag/ sgn)
    #|
    (write "     ")
    (display up)
    (write "/")
    (display down)
    (newline)
    |#
    (cond ((null? arr) (/ up down sgn))
          ((equal? (car arr) #\/) (loop (cdr arr) up down 1 sgn))
          ((equal? (car arr) #\+) (loop (cdr arr) up down flag/ +1))
          ((equal? (car arr) #\-) (loop (cdr arr) up down flag/ -1))
          ((= flag/ 0) (loop (cdr arr) (+ (* up 10)  (char->digit (car arr))) down flag/ sgn))
          (else (loop (cdr arr) up (+ (* down 10) (char->digit (car arr))) flag/ sgn))))
  (and (check-frac str) (loop (string->list str) 0 0 0 1)))

(define (search-f res arr)
  (if (null? arr)
      res
      (if (car arr)
          (search-f res (cdr arr))
          #f)))
      

(define (scan-many-fracs str)
  (define skip '(#\space #\tab #\newline))
  (define (loop arr frac res)
    (cond ((and (not (null? frac)) (null? arr)) (append res (list (scan-frac (list->string frac)))))
          ((null? arr)res)
          ;((equal? (car arr) #\\) (scan-frac (list->string frac)) (loop (cddr arr '())))
          ;((equal? (car arr) #\space) (scan-frac (list->string frac)) (loop (cdr arr)'()))
          ((and (not (null? frac)) (memq (car arr) skip));(write "|")(display (scan-frac (list->string frac)))
           (loop (cdr arr)'() (append res (list (scan-frac (list->string frac))))))
          ((memq (car arr) skip) (loop (cdr arr) frac res))
          (else ;(display (car arr))(newline)
           (loop (cdr arr) (append frac (list (car arr))) res))))
  (let ((arr (loop (string->list str) '() '())))
    (search-f arr arr)))


;;2
;(define funcs-arr '('+ '- '* 'mod 'neg '= '< '> 'not 'and 'or 'drop 'swap 'dup 'over 'rot 'depth 'if))
(define funcs-arr '(+ - * mod neg = < > not and or drop swap dup over rot depth if))

(define dict '())

(define x 0)

(define (parse vec)
  ;(parce (vector->list vec) (list dict '())))
  (list dict (parce (vector->list vec) '())))

(define (parce-define arr stack-return)
  (let ((x (car arr)))
    (if (equal? x 'end)
        (set! dict (cons  (cons  (car stack-return)  (list (cdr stack-return))) dict))
        (parce-define (cdr arr) (append stack-return (list x))))))

(define (parce arr res)
  (if (null? arr)
      res
      (let ((fnel (car arr)))
        (cond((member fnel funcs-arr) (cons res (list fnel (parce (cdr arr) '()))))
             ((equal? fnel 'define) (cons (cadr arr) funcs-arr) (parce-define (cdr arr) '()) (cons res (list (parce (cdr arr) '()))))
             ;((equal? fnel 'if) (append res (list (parce (cdr arr) '()))))
             ((equal? fnel 'exit) (parce (cdr arr) res))
             ((equal? fnel 'end) (parce (cdr arr) res))
             ((equal? fnel 'endif) (parce (cdr arr) res))
             (else (write fnel)(display " ")(set! x (++ x)) (write x)(newline) (parce (cdr arr) (append res (list fnel))))))))
#|

(define (scan-frac str)
  (define check-frac-arr (string->list "1234567890-/+"))
  (define frac 0)
  (define quot 0)
  (define sgn +)
  (define (loop listr aft)
    (cond
      ((null? listr) #t)
      ((memq (car listr) check-frac-arr)
       (cond
         ((equal? (car listr)#\/) (loop (cdr listr) 1))
         ((equal? (car listr)#\+) (loop (cdr listr) aft))
         ((and  (equal? (car listr) #\-) (= aft 0)) (set! sgn -) (loop (cdr listr) aft))
         ((and  (equal? (car listr) #\-) (= aft 1)) #f)
         (else
          (or
           (and (equal? aft 0) (set! frac (sgn (* frac 10)
                                               (char->digit (car listr)))))
           (and (equal? aft 1) (set! quot (+ (* quot 10)
                                             (char->digit (car listr))))))
          (loop (cdr listr) aft))))
      (else #f)))
  (and (loop (string->list str) 0)
       (not (= quot 0)) ;; не знаю, надо ли проверять деление на 0
       (/ frac quot))) ;; выводить через write! display выводит целую часть из дробей, нам этого не надо!
|#
