;;
(define counter 0)
(define(next)
  (set! counter (+ 1 counter))
  counter)
(define (signum x)
  (cond
    ((< x 0) -1)
    ((= x 0)  1) ; Ошибка здесь!
    (else     1)))
;;1
(define-syntax trace-ex
  (syntax-rules ()
    ((trace-ex expr)
     (begin (write 'expr)
            (display " => ")
            (let ((x expr))
              (write x)
              (newline)
              x)))))
;;2 run-test принимает только 1 переменную тест
(define (run-test arr)
  (let ((expr-res (eval (car arr) (interaction-environment)))
        (value (car(cdr arr)))
        (expr (car arr)))
    (if (equal? expr-res value)
        (begin
          (write expr)
          (display " ok")
          (newline))
        (begin
          (write expr)
          (display " FAIL")
          (newline)
          (display "  Expected:")
          (write value)
          (newline)
          (display "  Returned:")
          (write expr-res)
          (newline)))
    (equal? expr-res value)))
(define (run-tests arr)
  (or (null? arr)
      (if (run-test (car arr))
          (run-tests (cdr arr))
          (begin
            (run-tests (cdr arr))
            #f))))
(define-syntax test
  (syntax-rules ()
    ((test expr res)
     (list (quote expr) res))))
#|
(define (signum x)
  (cond
    ((< x 0) -1)
    ((= x 0)  1) ; Ошибка здесь!
    (else     1)))
(define the-tests
  (list (test (signum -2) -1)
        (test (signum  0)  0)
        (test (signum  2)  1)))
(run-tests the-tests) ->

(signum -2) ok
(signum 0) FAIL
  Expected:0
  Returned:1
(signum 2) ok
#f

|#
;;3
(define (ref arg . index-new)
  (define (transform-in-list arg)
    (if (string? arg)
        (string->list arg)
        (if (vector? arg)
            (vector->list arg)
            arg)))
  (define (func-list->type? arg)
    (if (string? arg)
        (lambda (x) (list->string x))
        (if (vector? arg)
            (lambda (x) (list->vector x))
            (lambda (x . xs) (car(append (list x) xs))))))
  (define (ref-1 xs index)
    (if (> index (- (length xs) 1))
        (< index (length xs));#f
        (if (= index 0)
            (car xs)
            (ref-1 (cdr xs) (- index 1)))))
  (define (ref-2 xs index replace list->old-type res)
    (if (> index (- (length xs) 1))
        (if (> index (length xs))
            (< index (length xs))
            (list->old-type (append xs (list replace))))
        (if (= index 0)
            (list->old-type (append res (list replace)  xs))
            (ref-2 (cdr xs) (- index 1) replace list->old-type (append res (list (car xs)))))))
  (cond ((and (not (and (not (list? arg))
                        (not (vector? arg))
                        (not (string? arg))))
              ( = (length index-new) 1))
         (ref-1 (transform-in-list arg) (car index-new)))
        ((and (not (and (not (list? arg)) (not (vector? arg)) (not (string? arg)))) (not ( = (length index-new) 1))
              (or (list? arg) (and (string? arg) (char? (car (cdr index-new)))) (vector? arg)))
         (ref-2 (transform-in-list arg) (car index-new) (car (cdr index-new)) (func-list->type? arg) '()))
        (else #f)))
#|
  (if (and (not (list? arg)) (not (vector? arg)) (not (string? arg)))
      #f
      (if ( = (length index-new) 1)
          (ref-1 (transform-in-list arg) (car index-new))
          (if (pair? index-new)
              (if (not (or (list? arg) (and (string? arg) (char? (car (cdr index-new)))) (vector? arg)))
                  #f
                  (ref-2 (transform-in-list arg) (car index-new) (car (cdr index-new)) (func-list->type? arg) '()))
              #f))))
|#
#|
(ref '(1 2 3) 1) ⇒ 2
(ref #(1 2 3) 1) ⇒ 2
(ref "123" 1)    ⇒ #\2
(ref "123" 3)    ⇒ #f

(ref '(1 2 3) 1 0)   ⇒ (1 0 2 3)
(ref #(1 2 3) 1 0)   ⇒ #(1 0 2 3)
(ref #(1 2 3) 1 #\0) ⇒ #(1 #\0 2 3)
(ref "123" 1 #\0)    ⇒ "1023"
(ref "123" 1 0)      ⇒ #f
(ref "123" 3 #\4)    ⇒ "1234"
(ref "123" 5 #\4)    ⇒ #f
|#
;;4
(define (factorize expr)
  (define (parsed signum power x y)
    (if (equal? signum '+)
        (list '+ (list 'expt x '3) (list '* '3  (list 'expt x '2) y)
              (list '* '3 x (list 'expt y '2)) (list 'expt y '3))
        (if (equal? power 2)
            (list '* (list '- x y) (list '+ x y))
            (list '+ (list 'expt x '3) (list '* '3  (list 'expt x '2) y '-1)
                  (list '* '3 x (list 'expt y '2)) (list '* (list 'expt y '3) '-1)))))
  (parsed (car expr) (car (cddr (car(cddr expr)))) (car (cdr (car (cdr expr)))) (car (cdr(car (cddr expr))))))
#|
(factorize '(- (expt x 2) (expt y 2))) 
  ⇒ (* (- x y) (+ x y))
  
(factorize '(- (expt (+ first 1) 2) (expt (- second 1) 2)))
  ⇒ (* (- (+ first 1) (- second 1))
         (+ (+ first 1) (- second 1)))
             
(eval (list (list 'lambda 
                      '(x y) 
                      (factorize '(- (expt x 2) (expt y 2))))
                1 2)
          (interaction-environment))
  ⇒ -3
|#

#|
(define (if-mistake expr arg)
  (display "fail")
  (newline)
  (display "Expected:")
  (write arg)
  (newline)
  (display "Returned:")
  (if (procedure? expr)
      (write (expr arg))
      (write expr)))
(define (ok)
  (display " ok")
  (newline))
(define (run-test expr arg)
  (write 'expr)
  (if (procedure? expr)
      (if (eqv? (expr arg) arg)
          (ok)
          (if-mistake expr arg))
      (if (eqv? expr arg)
          (ok)
          (if-mistake expr arg))))
(define (run-tests expr args)
  (map (lambda (x) (run-test expr x)) args))
#|
  (set! counter 5)
(define next-tests
    (list (test (next) 6)
          (test (next) 8)
          (test (next) 8)))
|#     
(define-syntax test
  (syntax-rules ()
    ((test expr args)
     (begin (if (list? args)
                (run-tests expr (list args))
                (run-test expr args))))))
|#
