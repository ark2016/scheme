;;
(define counter 0)
(define(next)
  (set! counter (+ 1 counter))
  counter)
(define (signum x)
  (cond
    ((< x 0) -1)
    ((= x 0)  1) ; Ошибка здесь!
    (else     1)))
;;1
(define-syntax trace-ex
  (syntax-rules ()
    ((trace-ex expr)
     (begin (write 'expr)
            (display " => ")
            (let ((x expr))
              (write x)
              (newline)
              x)))))
;;2 run-test принимает только 1 переменную тест
(define (run-test arr)
  (let ((expr-res (eval (car arr) (interaction-environment)))
        (value (car(cdr arr)))
        (expr (car arr)))
    (if (equal? expr-res value)
        (begin
          (write expr)
          (display " ok")
          (newline))
        (begin
          (write expr)
          (display " FAIL")
          (newline)
          (display "  Expected:")
          (write value)
          (newline)
          (display "  Returned:")
          (write expr-res)
          (newline)))
    (equal? expr-res value)))
(define (run-tests arr)
  (or (null? arr)
      (if (run-test (car arr))
          (run-tests (cdr arr))
          (begin
            (run-tests (cdr arr))
            #f))))
(define-syntax test
  (syntax-rules ()
    ((test expr res)
     (list (quote expr) res))))
;;3
(define (ref arg . index-new)
  (define (transform-in-list arg)
    (if (string? arg)
        (string->list arg)
        (if (vector? arg)
            (vector->list arg)
            arg)))
  (define (func-list->type? arg)
    (if (string? arg)
        (string->list)
        (if (vector? arg)
            (vector->list)
            (lambda (x . xs) (car(append (list x) xs))))))
  (define (ref-1 xs index)
    (if (> index (- (length xs) 1))
        (< index (length xs));#f
        (if (= index 0)
            (car xs)
            (ref-1 (cdr xs) (- index 1)))))
  (define (ref-2 xs index replace list->old-type res)
    (if (> index (- (length xs) 1))
        (< index (length xs));#f
        (if (= index 0)
            (list->old-type (append res (list replace) (cdr xs)))
            (ref-2 (cdr xs) (- index 1) replace list->old-type (append res (list (car xs)))))))
  (if (and (not (list? arg)) (not (vector? arg)) (not (string? arg)))
      (display "wrong input")
      (if ( = (length index-new) 1)
          (ref-1 (transform-in-list arg) (car index-new))
          (if (pair? index-new)
              (ref-2 (transform-in-list arg) (car index-new) (car (cdr index-new)) (func-list->type? arg) '())
              (display "Wrong input")))))
;;4
(define (factorize expr)
  (define (loop signum power x y)
    (if (equal? signum '+)
        (list '+ (list 'expt x '3) (list '* '3  (list 'expt x '2) y)
              (list '* '3 x (list 'expt y '2)) (list 'expt y '3))
        (if (equal? power 2)
            (list '* (list '- x y) (list '+ x y))
            (list '+ (list 'expt x '3) (list '* '3  (list 'expt x '2) y '-1)
                  (list '* '3 x (list 'expt y '2)) (list '* (list 'expt y '3) '-1)))))
  (loop (car expr) (car (cddr (car(cddr expr)))) (car (cdr (car (cdr expr)))) (car (cdr(car (cddr expr))))))

      
#|
(define (if-mistake expr arg)
  (display "fail")
  (newline)
  (display "Expected:")
  (write arg)
  (newline)
  (display "Returned:")
  (if (procedure? expr)
      (write (expr arg))
      (write expr)))
(define (ok)
  (display " ok")
  (newline))
(define (run-test expr arg)
  (write 'expr)
  (if (procedure? expr)
      (if (eqv? (expr arg) arg)
          (ok)
          (if-mistake expr arg))
      (if (eqv? expr arg)
          (ok)
          (if-mistake expr arg))))
(define (run-tests expr args)
  (map (lambda (x) (run-test expr x)) args))
#|
  (set! counter 5)
(define next-tests
    (list (test (next) 6)
          (test (next) 8)
          (test (next) 8)))
|#     
(define-syntax test
  (syntax-rules ()
    ((test expr args)
     (begin (if (list? args)
                (run-tests expr (list args))
                (run-test expr args))))))
|#
