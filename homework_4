;;1
(define memoized-factorial
  (let ((known-results '()))
    (lambda (n)
      (let* ((arg (list n))
             (res (assoc arg known-results)))
        (if res
            (cadr res)
            (let ((res (! n)))
              (set! known-results (cons (list arg res) known-results))
              res))))))

(define (! n)
  (if (<= n 1)
      1
      (* n (! (- n 1)))))
;;2
(define-syntax lazy-cons
  (syntax-rules ()
    ((lazy-cons a b)
     (let ((b-promise (delay b)))
       (cons a b-promise)))))

(define (lazy-car p)
  (force (car p)))

(define (lazy-cdr p)
  (force (cdr p)))

(define (lazy-head* xs k)
  (if (> k 0)
      (lazy-head* (cons (lazy-car xs) (cdr xs)) (- k 1))
      xs))

(define (lazy-head xs k)
  (define (loop xs k res)
    (if (not (null? res))
        (display  (car (force (car (cdr xs))))))
    (newline)
    (if (> k 0)
        (loop (force (car (cdr xs))) (- k 1) (append res (force (car (cdr xs)))))
        ;        (loop (force (car (cdr xs))) (- k 1) (display (car(force (car(cdr xs))))))
        ;        (loop (cdr xs) (- k 1) (append res (force (car (cdr xs)))))
        res))
  (loop xs k '()))
#|
(define (lazy-head* xs k)
  (if (> k 0)
      (if (number? (car xs))
          (
      xs))
|#
(define (lazy-ref xs k)
  (if (= k 0)
      (lazy-car xs)
      (lazy-ref (cdr xs) (- k 1))))

(define (naturals start)
  (cons start (cons (delay (naturals (+ start 1))) '())))














